(()=>{var t={97:()=>{class t extends HTMLElement{constructor(){super(),this.attachShadow({mode:"open"}),this.polygons=[],this.shadowRoot.innerHTML='\n      <style>\n        .zone {\n          height: 150px;\n          background: #eef;\n          display: flex;\n          flex-wrap: wrap;\n          padding: 10px;\n          gap: 10px;\n        }\n        .svg-wrapper {\n          width: 100px;\n          height: 100px;\n          cursor: grab;\n        }\n        svg {\n          width: 100%;\n          height: 100%;\n        }\n      </style>\n      <div class="zone"></div>\n    ',this.container=this.shadowRoot.querySelector(".zone");const t=localStorage.getItem("polygons");t&&this.setPolygons(JSON.parse(t))}generatePolygons(){const t=Math.floor(16*Math.random())+5,e=Array.from({length:t},(()=>this.randomPolygon()));this.setPolygons(e)}randomPolygon(){const t=[],e=Math.floor(4*Math.random())+3;for(let s=0;s<e;s++){const e=Math.floor(100*Math.random()),s=Math.floor(100*Math.random());t.push([e,s])}return t}renderPolygons(){this.container.innerHTML="",this.polygons.forEach((t=>{const e=document.createElementNS("http://www.w3.org/2000/svg","svg");e.setAttribute("width","100"),e.setAttribute("height","100");const s=document.createElementNS("http://www.w3.org/2000/svg","polygon");s.setAttribute("points",t.map((t=>t.join(","))).join(" ")),s.setAttribute("fill","lightgreen"),s.setAttribute("stroke","black"),e.appendChild(s);const i=document.createElement("div");i.classList.add("svg-wrapper"),i.setAttribute("draggable","true"),i.ondragstart=t=>{console.log("üî• drag started");const s=e.cloneNode(!0);s.setAttribute("xmlns","http://www.w3.org/2000/svg");const i=(new XMLSerializer).serializeToString(s);t.dataTransfer.setData("image/svg+xml",i),t.dataTransfer.setData("text/plain",i),t.dataTransfer.effectAllowed="copy"},i.appendChild(e),this.container.appendChild(i)}))}getPolygons(){return this.polygons}setPolygons(t){this.polygons=t,this.renderPolygons()}}customElements.define("svg-zone",t)},490:()=>{class t extends HTMLElement{constructor(){super(),this.attachShadow({mode:"open"}),this.render(),this.grid=this.shadowRoot.getElementById("grid"),this.xAxis=this.shadowRoot.getElementById("x-axis"),this.yAxis=this.shadowRoot.getElementById("y-axis"),this.gridCtx=this.grid.getContext("2d"),this.xCtx=this.xAxis.getContext("2d"),this.yCtx=this.yAxis.getContext("2d"),this.scale=1,this.step=50,this.maxGridWidth=2e3,this.maxGridHeight=1e3,this.offsetX=0,this.offsetY=0,this.isDragging=!1,this.dragStart={x:0,y:0},this.dragOffsetStart={x:0,y:0},this.droppedPolygons=[],this.addEventListeners(),this.resizeObserver=new ResizeObserver((()=>this.resize())),this.resizeObserver.observe(this),this.shadowRoot.addEventListener("dragover",(t=>this.onDragOver(t))),this.shadowRoot.addEventListener("drop",(t=>this.onDrop(t)))}connectedCallback(){this.resize()}render(){this.shadowRoot.innerHTML='\n      <style>\n        :host {\n          display: block;\n          width: 100%;\n          height: 100%;\n          position: relative;\n          user-select: none;\n          overflow: hidden;\n          background: white;\n        }\n        canvas {\n          position: absolute;\n          background: white;\n        }\n        #grid {\n          top: 0;\n          left: 40px;\n          width: calc(100% - 40px);\n          bottom: 40px;\n          height: calc(100% - 40px);\n          z-index: 1;\n          cursor: grab;\n        }\n        #grid.dragging {\n          cursor: grabbing;\n        }\n        #x-axis {\n          height: 40px;\n          left: 40px;\n          bottom: 0;\n          width: calc(100% - 40px);\n          z-index: 4;\n          border-top: 1px solid black;\n        }\n        #y-axis {\n          width: 40px;\n          top: 0;\n          left: 0;\n          height: calc(100% - 40px);\n          z-index: 4;\n          border-right: 1px solid black;\n        }\n        .svg-layer {\n          position: absolute;\n          top: 0;\n          left: 40px;\n          width: calc(100% - 40px);\n          height: calc(100% - 40px);\n          pointer-events: none; /* —á—Ç–æ–±—ã –Ω–µ –º–µ—à–∞—Ç—å –º—ã—à–∏ –Ω–∞ —Å–µ—Ç–∫–µ */\n          overflow: visible;\n          z-index: 3;\n        }\n        .svg-layer > svg {\n          position: absolute;\n          will-change: transform;\n          pointer-events: auto; /* —á—Ç–æ–±—ã SVG –º–æ–∂–Ω–æ –±—ã–ª–æ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞—Ç—å */\n          cursor: move;\n        }\n      </style>\n      <canvas id="grid"></canvas>\n      <canvas id="x-axis"></canvas>\n      <canvas id="y-axis"></canvas>\n      <div class="svg-layer"></div>\n    ',this.svgLayer=this.shadowRoot.querySelector(".svg-layer")}resize(){const t=this.clientWidth,e=this.clientHeight;this.grid.width=t-40,this.grid.height=e-40,this.xAxis.width=t-40,this.xAxis.height=40,this.yAxis.width=40,this.yAxis.height=e-40,this.clampOffsets(),this.draw()}addEventListeners(){this.grid.addEventListener("wheel",(t=>this.onWheel(t)),{passive:!1}),this.grid.addEventListener("mousedown",(t=>this.onDragStart(t))),window.addEventListener("mousemove",(t=>this.onDragMove(t))),window.addEventListener("mouseup",(()=>this.onDragEnd()))}clampOffsets(){const t=Math.max(0,this.maxGridWidth-this.grid.width/this.scale),e=Math.max(0,this.maxGridHeight-this.grid.height/this.scale);this.offsetX=Math.min(Math.max(this.offsetX,0),t),this.offsetY=Math.min(Math.max(this.offsetY,0),e)}onWheel(t){t.preventDefault();const e=.001*-t.deltaY;let s=this.scale*(1+e);if(s=Math.min(Math.max(s,1),5),s===this.scale)return;const i=this.grid.getBoundingClientRect(),n=t.clientX-i.left,o=t.clientY-i.top,a=this.offsetX+n/this.scale,r=this.offsetY+(this.grid.height-o)/this.scale;this.scale=s,this.offsetX=a-n/this.scale,this.offsetY=r-(this.grid.height-o)/this.scale,this.clampOffsets(),this.updateSvgPositions(),this.draw()}onDragStart(t){this.isDragging=!0,this.grid.classList.add("dragging"),this.dragStart.x=t.clientX,this.dragStart.y=t.clientY,this.dragOffsetStart.x=this.offsetX,this.dragOffsetStart.y=this.offsetY}onDragMove(t){if(!this.isDragging)return;const e=(t.clientX-this.dragStart.x)/this.scale,s=(t.clientY-this.dragStart.y)/this.scale;this.offsetX=this.dragOffsetStart.x-e,this.offsetY=this.dragOffsetStart.y+s,this.clampOffsets(),this.updateSvgPositions(),this.draw()}onDragEnd(){this.isDragging&&(this.isDragging=!1,this.grid.classList.remove("dragging"))}onDragOver(t){t.preventDefault(),t.dataTransfer.dropEffect="copy"}onDrop(t){t.preventDefault();const e=t.dataTransfer.getData("image/svg+xml")||t.dataTransfer.getData("text/plain");if(!e)return;const s=(new DOMParser).parseFromString(e,"image/svg+xml").querySelector("svg");if(!s)return;const i=this.grid.getBoundingClientRect(),n=t.clientX-i.left,o=t.clientY-i.top,a=this.offsetX+n/this.scale,r=this.offsetY+(this.grid.height-o)/this.scale,h=s.cloneNode(!0);h.removeAttribute("width"),h.removeAttribute("height"),h.style.position="absolute",h.style.transformOrigin="0 0",h.style.width="100px",h.style.height="100px",this.svgLayer.appendChild(h),this.droppedPolygons.push({svgString:e,logicalX:a,logicalY:r,svgElement:h}),this.updateSvgPositions()}updateSvgPositions(){const t=this.grid.height;this.droppedPolygons.forEach((({logicalX:e,logicalY:s,svgElement:i})=>{const n=(e-this.offsetX)*this.scale,o=t-(s-this.offsetY)*this.scale;i.style.transform=`translate(${n}px, ${o}px) scale(${this.scale})`}))}clear(t){t.clearRect(0,0,t.canvas.width,t.canvas.height)}draw(){this.clear(this.gridCtx),this.clear(this.xCtx),this.clear(this.yCtx),this.drawGrid(),this.drawXAxis(),this.drawYAxis()}drawGrid(){const t=this.gridCtx,e=t.canvas.width,s=t.canvas.height;t.strokeStyle="#ddd",t.lineWidth=1,t.beginPath();const i=Math.floor(this.offsetX/this.step)*this.step,n=this.offsetX+e/this.scale;for(let e=i;e<=n;e+=this.step){const i=Math.round((e-this.offsetX)*this.scale)+.5;t.moveTo(i,0),t.lineTo(i,s)}const o=Math.floor(this.offsetY/this.step)*this.step,a=this.offsetY+s/this.scale;for(let i=o;i<=a;i+=this.step){const n=Math.round(s-(i-this.offsetY)*this.scale)+.5;t.moveTo(0,n),t.lineTo(e,n)}t.stroke()}drawXAxis(){const t=this.xCtx,e=t.canvas.width,s=t.canvas.height;t.strokeStyle="black",t.fillStyle="black",t.lineWidth=1,t.font="12px sans-serif",t.textAlign="center",t.textBaseline="bottom",t.beginPath();const i=Math.floor(this.offsetX/this.step)*this.step,n=this.offsetX+e/this.scale;for(let e=i;e<=n;e+=this.step){const i=Math.round((e-this.offsetX)*this.scale)+.5;t.moveTo(i,s),t.lineTo(i,s-10),t.fillText(Math.round(e),i,s-12)}t.stroke()}drawYAxis(){const t=this.yCtx,e=t.canvas.width,s=t.canvas.height;t.strokeStyle="black",t.fillStyle="black",t.lineWidth=1,t.font="12px sans-serif",t.textAlign="right",t.textBaseline="middle",t.beginPath();const i=Math.floor(this.offsetY/this.step)*this.step,n=this.offsetY+s/this.scale;for(let o=i;o<=n;o+=this.step){const i=Math.round(s-(o-this.offsetY)*this.scale)+.5;t.moveTo(e,i),t.lineTo(e-10,i),t.fillText(Math.round(o),e-12,i)}t.stroke()}}customElements.define("work-zone",t)}},e={};function s(i){var n=e[i];if(void 0!==n)return n.exports;var o=e[i]={exports:{}};return t[i](o,o.exports,s),o.exports}s.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return s.d(e,{a:e}),e},s.d=(t,e)=>{for(var i in e)s.o(e,i)&&!s.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},s.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),(()=>{"use strict";s(97),s(490);const t=document.getElementById("createBtn"),e=document.getElementById("saveBtn"),i=document.getElementById("clearBtn"),n=document.querySelector("svg-zone"),o=document.querySelector("work-zone");t.onclick=()=>{n.generatePolygons()},e.onclick=()=>{const t=n.getPolygons();localStorage.setItem("polygons",JSON.stringify(t))},i.onclick=()=>{localStorage.removeItem("polygons"),n.setPolygons([]),o.clearPolygons()}})()})();